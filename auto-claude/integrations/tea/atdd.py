"""TEA ATDD (Acceptance Test-Driven Development) integration.

Generates failing acceptance tests from TEA test plans.
"""

import logging
from pathlib import Path
from string import Template

from .models import TestPlan, TestCase, TestFramework

logger = logging.getLogger(__name__)


# Pytest template for generating failing tests
PYTEST_TEMPLATE = '''"""
Acceptance tests for Story ${story_id}
Generated by TEA ATDD workflow

These tests should FAIL initially (red phase).
Implementation should make them pass (green phase).
"""
import pytest

${setup_fixture}
${test_classes}
'''

PYTEST_SETUP_FIXTURE = '''
@pytest.fixture(autouse=True)
def setup():
    """Test setup."""
    ${setup}
    yield
    ${teardown}
'''

PYTEST_TEST_CLASS = '''
class Test${class_name}:
    """${description}

    AC: ${acceptance_criteria_id}
    Priority: ${priority}
    """

    def test_${test_id}(self):
        """
        Given: ${given}
        When: ${when}
        Then: ${then}
        """
        # TODO: Implement this test
        # This test should FAIL until implementation is complete
        pytest.fail("Not implemented - coder agent should make this pass")
'''

# Jest/Vitest template
JEST_TEMPLATE = '''/**
 * Acceptance tests for Story ${story_id}
 * Generated by TEA ATDD workflow
 *
 * These tests should FAIL initially (red phase).
 * Implementation should make them pass (green phase).
 */

${setup_block}
${test_describes}
'''

JEST_SETUP_BLOCK = '''
beforeAll(() => {
  ${setup}
});

afterAll(() => {
  ${teardown}
});
'''

JEST_DESCRIBE = '''
describe('${name}', () => {
  /**
   * ${description}
   * AC: ${acceptance_criteria_id}
   * Priority: ${priority}
   */

  it('${test_id}: ${then_clause}', () => {
    // Given: ${given}
    // When: ${when}
    // Then: ${then}

    // TODO: Implement this test
    // This test should FAIL until implementation is complete
    expect(false).toBe(true); // Intentional failure
  });
});
'''


async def generate_atdd_tests(
    test_plan: TestPlan,
    project_path: Path,
) -> list[Path]:
    """Generate failing acceptance tests from test plan.

    Args:
        test_plan: TEA test plan
        project_path: Project root path

    Returns:
        List of generated test file paths
    """
    generated_files = []

    # Determine test directory and create it
    test_dir = get_test_directory(project_path, test_plan.framework)
    test_dir.mkdir(parents=True, exist_ok=True)

    # Generate test file name
    test_file_name = f"test_{test_plan.story_id.replace('-', '_')}.{get_extension(test_plan.framework)}"
    test_file_path = test_dir / test_file_name

    # Render test content based on framework
    if test_plan.framework == TestFramework.PYTEST:
        test_content = render_pytest_tests(test_plan)
    elif test_plan.framework in (TestFramework.JEST, TestFramework.VITEST):
        test_content = render_jest_tests(test_plan)
    elif test_plan.framework == TestFramework.GO_TEST:
        test_content = render_go_tests(test_plan)
    elif test_plan.framework == TestFramework.CARGO_TEST:
        test_content = render_rust_tests(test_plan)
    else:
        # Default to pytest style
        test_content = render_pytest_tests(test_plan)

    # Write test file
    test_file_path.write_text(test_content)
    generated_files.append(test_file_path)

    logger.info(f"Generated ATDD tests at {test_file_path}")

    return generated_files


def render_pytest_tests(test_plan: TestPlan) -> str:
    """Render pytest test file content."""
    # Build setup fixture if needed
    setup_fixture = ""
    if test_plan.setup_instructions or test_plan.teardown_instructions:
        setup_fixture = Template(PYTEST_SETUP_FIXTURE).safe_substitute(
            setup=test_plan.setup_instructions or "pass",
            teardown=test_plan.teardown_instructions or "pass",
        )

    # Build test classes
    test_classes = []
    for tc in test_plan.test_cases:
        class_name = tc.name.replace(" ", "").replace("-", "")
        test_id = tc.id.replace("-", "_")

        test_class = Template(PYTEST_TEST_CLASS).safe_substitute(
            class_name=class_name,
            description=tc.description,
            acceptance_criteria_id=tc.acceptance_criteria_id,
            priority=tc.priority,
            test_id=test_id,
            given=tc.given,
            when=tc.when,
            then=tc.then,
        )
        test_classes.append(test_class)

    return Template(PYTEST_TEMPLATE).safe_substitute(
        story_id=test_plan.story_id,
        setup_fixture=setup_fixture,
        test_classes="\n".join(test_classes),
    )


def render_jest_tests(test_plan: TestPlan) -> str:
    """Render Jest/Vitest test file content."""
    # Build setup block if needed
    setup_block = ""
    if test_plan.setup_instructions or test_plan.teardown_instructions:
        setup_block = Template(JEST_SETUP_BLOCK).safe_substitute(
            setup=test_plan.setup_instructions or "// No setup",
            teardown=test_plan.teardown_instructions or "// No teardown",
        )

    # Build describe blocks
    describes = []
    for tc in test_plan.test_cases:
        describe = Template(JEST_DESCRIBE).safe_substitute(
            name=tc.name,
            description=tc.description,
            acceptance_criteria_id=tc.acceptance_criteria_id,
            priority=tc.priority,
            test_id=tc.id,
            then_clause=tc.then[:50] + "..." if len(tc.then) > 50 else tc.then,
            given=tc.given,
            when=tc.when,
            then=tc.then,
        )
        describes.append(describe)

    return Template(JEST_TEMPLATE).safe_substitute(
        story_id=test_plan.story_id,
        setup_block=setup_block,
        test_describes="\n".join(describes),
    )


def render_go_tests(test_plan: TestPlan) -> str:
    """Render Go test file content."""
    lines = [
        f"// Acceptance tests for Story {test_plan.story_id}",
        "// Generated by TEA ATDD workflow",
        "//",
        "// These tests should FAIL initially (red phase).",
        "// Implementation should make them pass (green phase).",
        "",
        "package main",
        "",
        'import "testing"',
        "",
    ]

    for tc in test_plan.test_cases:
        func_name = tc.name.replace(" ", "").replace("-", "")
        lines.extend([
            f"// Test{func_name} tests: {tc.description}",
            f"// AC: {tc.acceptance_criteria_id}",
            f"// Priority: {tc.priority}",
            f"func Test{func_name}(t *testing.T) {{",
            f"\t// Given: {tc.given}",
            f"\t// When: {tc.when}",
            f"\t// Then: {tc.then}",
            "\t",
            "\t// TODO: Implement this test",
            '\tt.Fatal("Not implemented - coder agent should make this pass")',
            "}",
            "",
        ])

    return "\n".join(lines)


def render_rust_tests(test_plan: TestPlan) -> str:
    """Render Rust test file content."""
    lines = [
        f"//! Acceptance tests for Story {test_plan.story_id}",
        "//! Generated by TEA ATDD workflow",
        "//!",
        "//! These tests should FAIL initially (red phase).",
        "//! Implementation should make them pass (green phase).",
        "",
    ]

    for tc in test_plan.test_cases:
        test_name = tc.id.replace("-", "_")
        lines.extend([
            f"/// {tc.description}",
            f"///",
            f"/// AC: {tc.acceptance_criteria_id}",
            f"/// Priority: {tc.priority}",
            f"///",
            f"/// Given: {tc.given}",
            f"/// When: {tc.when}",
            f"/// Then: {tc.then}",
            "#[test]",
            f"fn test_{test_name}() {{",
            "    // TODO: Implement this test",
            '    panic!("Not implemented - coder agent should make this pass");',
            "}",
            "",
        ])

    return "\n".join(lines)


def get_test_directory(project_path: Path, framework: TestFramework) -> Path:
    """Determine correct test directory for framework."""
    if framework == TestFramework.PYTEST:
        return project_path / "tests" / "acceptance"
    elif framework in (TestFramework.JEST, TestFramework.VITEST):
        return project_path / "src" / "__tests__" / "acceptance"
    elif framework == TestFramework.GO_TEST:
        return project_path  # Go tests in same directory as code
    elif framework == TestFramework.CARGO_TEST:
        return project_path / "tests"
    return project_path / "tests"


def get_extension(framework: TestFramework) -> str:
    """Get file extension for framework."""
    if framework in (TestFramework.JEST, TestFramework.VITEST):
        return "test.ts"
    elif framework == TestFramework.GO_TEST:
        return "go"
    elif framework == TestFramework.CARGO_TEST:
        return "rs"
    return "py"


async def verify_tests_fail(
    test_file: Path,
    framework: TestFramework,
    project_path: Path
) -> bool:
    """Verify generated tests fail (red phase).

    Returns True if tests fail as expected.
    """
    import subprocess

    try:
        if framework == TestFramework.PYTEST:
            result = subprocess.run(
                ["pytest", str(test_file), "-v", "--tb=no"],
                cwd=project_path,
                capture_output=True,
                timeout=60,
            )
            return result.returncode != 0  # Should fail

        elif framework in (TestFramework.JEST, TestFramework.VITEST):
            result = subprocess.run(
                ["npm", "test", "--", str(test_file)],
                cwd=project_path,
                capture_output=True,
                timeout=60,
            )
            return result.returncode != 0

        elif framework == TestFramework.GO_TEST:
            result = subprocess.run(
                ["go", "test", "-v", str(test_file)],
                cwd=project_path,
                capture_output=True,
                timeout=60,
            )
            return result.returncode != 0

        elif framework == TestFramework.CARGO_TEST:
            result = subprocess.run(
                ["cargo", "test"],
                cwd=project_path,
                capture_output=True,
                timeout=60,
            )
            return result.returncode != 0

    except (subprocess.TimeoutExpired, FileNotFoundError) as e:
        logger.warning(f"Could not verify tests fail: {e}")

    return True  # Assume fail for unknown frameworks or errors


async def build_coder_context(
    story_id: str,
    test_files: list[Path],
) -> dict:
    """Build context for coder agent including ATDD tests.

    Args:
        story_id: Story identifier
        test_files: Generated ATDD test files

    Returns:
        Context dict for coder agent
    """
    test_file_list = "\n".join(f"- {f}" for f in test_files)

    return {
        "story_id": story_id,
        "acceptance_tests": [
            {
                "path": str(f),
                "content": f.read_text() if f.exists() else "",
            }
            for f in test_files
        ],
        "instructions": f"""
## Implementation Instructions

1. Read the acceptance tests in the provided test files
2. Implement the feature to make ALL tests pass
3. Do not modify the test assertions
4. Run tests after each change to verify progress
5. Implementation is complete when all acceptance tests pass

## Test Files
{test_file_list}
        """,
    }
